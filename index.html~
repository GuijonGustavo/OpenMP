<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- This manual is for program, version version. Copyright C years copyright-owner.
Permission is granted to creative commons, by Gustavo Magallanes-Guijón
 -->
<!-- Created on el 7 octubre 2019 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>docs</title>

<meta name="description" content="docs">
<meta name="keywords" content="docs">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Top"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Tutorial-de-OpenMP"></a>
<h1 class="settitle">Tutorial de OpenMP</h1>
<p>Gustavo Magallanes-Guijón
</p><p>This manual is for program, version version. Copyright &copy; years copyright-owner.
Permission is granted to creative commons, by Gustavo Magallanes-Guijón
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fchapter_005f1">1. Introducción</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#node_005fchapter_005f2">2. Directivas</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Uso y ejemplos de las directivas de OpenMP
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fchapter_005f3">3. Clausulas</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Ejemplos y explicación de las clausulas
</td></tr>
</table>

                                                

<hr size="1">
<a name="node_005fchapter_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Introduccion"></a>
<h1 class="chapter">1. Introducción</h1>
                                                
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsection_005f1_005f1">1.1 SorJuana</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsection_005f1_005f2">1.2 OpenMP?</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsection_005f1_005f3">1.3 Compilación</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>
                                      
                                                
<hr size="6">
<a name="node_005fsection_005f1_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f1_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="SorJuana"></a>
<h2 class="section">1.1 SorJuana</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f1_005f1_005f1">1.1.1 Información</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f1_005f1_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f2" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Informacion"></a>
<h3 class="subsection">1.1.1 Información</h3>

<p>Se cuenta con una computadora con 48 núcleos y básicamente con las mismas características cada uno de ellos.
</p>
<p><b>processor</b>	: 0
</p>
<p>vendor_id	: GenuineIntel
</p>
<p>cpu family	: 6
</p>
<p>model		: 79
</p>
<p>model name	: Intel(R) Xeon(R) CPU E5-2650 v4 &nbsp;2.20GHz
</p>
<p>stepping	: 1
</p>
<p>microcode	: 0xb00001d
</p>
<p>cpu MHz		: 1204.567
</p>
<p>cache size	: 30720 KB
</p>
<p>physical id	: 0
</p>
<p>siblings	: 24
</p>
<p>core id		: 0
</p>
<p>cpu cores	: 12
</p>
<p>apicid		: 0
</p>
<p>initial apicid	: 0
</p>
<p>fpu		: yes
</p>
<p>fpu_exception	: yes
</p>
<p>cpuid level	: 20
</p>
<p>wp		: yes
</p>
<p>flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l3 cdp_l3 invpcid_single pti intel_ppin tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm rdt_a rdseed adx smap intel_pt xsaveopt cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm ida arat pln pts
</p>
<p>bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs
</p>
<p>bogomips	: 4400.15
</p>
<p>clflush size	: 64
</p>
<p>cache_alignment	: 64
</p>
<p>address sizes	: 46 bits physical, 48 bits virtual
</p>
<p>power management:
</p> 
<hr size="6">
<a name="node_005fsection_005f1_005f2"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f1_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f2_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="OpenMP_003f"></a>
<h2 class="section">1.2 OpenMP?</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f1_005f2_005f1">1.2.1 Ejemplo 1.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f1_005f2_005f2">1.2.2 Ejemplo 2.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f1_005f2_005f3">1.2.3 Ejemplo 2.3</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f1_005f2_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f2" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f2_005f2" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f2" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-1_002e1"></a>
<h3 class="subsection">1.2.1 Ejemplo 1.1</h3>

<pre class="smallexample"><p><b>Empecemos por hacer el análisis del primer ejemplo que se propone en el manual de OpenMP. Para esto, ejecutemos el ejemplo sin paralelizar, es decir sin el uso de la sintaxis de OpenMP.</b>
</p></pre>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 100

void simple(int n, float *a, float *b);

int main()
{

    int n = 6;
    float a[TAMANO];
    float b[TAMANO];

    simple(n, a, b);
    return 0; 

}

void simple(int n, float *a, float *b)
{
    int i;
    for( i=1; i&lt;n; i++ )
        {
            b[i]=( a[i] + b[i-1] ) / 2.0;
        printf(&quot;Checkpoint 1: b[%d] = %f. Thread # %d\n\n&quot;, i, b[i], omp_get_thread_num());
        }
        printf(&quot;Checkpoint 2: b[%d] = %f. Thread # %d\n\n&quot;, i, b[i], omp_get_thread_num());

}

</pre>
<p><b>Una vez ejecutado el ejemplo, obtenemos los siguientes resultados:</b>
</p>
<p>Checkpoint 1: b[1] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: b[2] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: b[3] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: b[4] = 0.000001. Thread # 0
</p>
<p>Checkpoint 1: b[5] = 0.000000. Thread # 0
</p>
<p>Checkpoint 2: b[6] = 0.000000. Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>En primer lugar observamos que el único hilo o thread que es registrado es el Thread: #0, que es el único que está en función desde el inicio hasta el fin de script.
</p>
<p>También hay que notar que en el <b>checkpoint 1</b> el índice <i>i</i> se imprime de manera ordenada y creciente. En el <b>checkpoint 2</b>, dado que en el ciclo <i>for</i> tenemos postincremento de la variable <b>i</b> se tiene <b>b[6]</b>.
</p>
<p><b>Ahora vamos a ejecutar este mismo ejemplo pero ahora sí usando la usando la sintaxis de OpenMP y configurando la paralelización para 6 threads:</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 100

void simple(int n, float *a, float *b);

int main()
{

    int n = 11;
    float a[TAMANO];
    float b[TAMANO];

    simple(n, a, b);
    return 0; 

}

void simple(int n, float *a, float *b)
{
    int i;
    #pragma omp parallel for num_threads(6)
    for( i=1; i&lt;n; i++ )
        {
            b[i]=( a[i] + b[i-1] ) / 2.0;
        printf(&quot;Checkpoint 1: b[i] = %f. Thread # %d\n\n&quot;, b[i], omp_get_thread_num());
        }
        printf(&quot;Checkpoint 2: b[i] = %f. Thread # %d\n\n&quot;, b[i], omp_get_thread_num());

}

</pre><p><b>Obteniendo en este caso como resultado:</b>
</p>
<p>Checkpoint 1: b[1] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: b[4] = 0.000000. Thread # 3
</p>
<p>Checkpoint 1: b[5] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: b[2] = 0.000000. Thread # 1
</p>
<p>Checkpoint 1: b[3] = 0.000000. Thread # 2
</p>
<p>Checkpoint 2: b[0] = 0.000000. Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Tomando en cuenta que solo se definieron 6 threads con la instrucción <b>omp_get_thread_num</b>  vemos que se usaron sólo los threads 0, 1, 2, 3, 4, 5. Por lo que hay un thread inutilizado, en este caso el thread #6. Lo mejor es ajustar el número de threads necesarios. En este caso la configuración óptima es: <b>num_threads(5)</b> que es la que coincide con el número de incremento máximo	que puede tener la variable <i>i</i>.
</p>
<p>El <b>checkpoint 1</b>, ademas de usar los threads 0-5 se aprecia que el valor de la variable <b>i</b> no coincide con el del thread. Esto es debido a que cada thread toma un valor de <b>i</b> sin importar el orden. Es decir, una vez que el thread #0 entra al bloque a paralelizar se segenera un <i>team</i> de threads que tomaran cada uno de los valores de la variable del ciclo <i>for</i>.  
</p>
<p><b>Ahora veamos cuál sería el resultado disminuyendo el número de threads a 2:</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 100

void simple(int n, float *a, float *b);

int main()
{

    int n = 11;
    float a[TAMANO];
    float b[TAMANO];

    simple(n, a, b);
    return 0; 

}

void simple(int n, float *a, float *b)
{
    int i;
    #pragma omp parallel for num_threads(2)
    for( i=1; i&lt;n; i++ )
        {
            b[i]=( a[i] + b[i-1] ) / 2.0;
        printf(&quot;Checkpoint 1: b[i] = %f. Thread # %d\n\n&quot;, b[i], omp_get_thread_num());
        }
        printf(&quot;Checkpoint 2: b[i] = %f. Thread # %d\n\n&quot;, b[i], omp_get_thread_num());

}

</pre><p><b>Obteniendo en este caso como resultado:</b>
</p>
<p>Checkpoint 1: b[4] = 0.000000. Thread # 1
</p>
<p>Checkpoint 1: b[5] = 0.000000. Thread # 1
</p>
<p>Checkpoint 1: b[1] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: b[2] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: b[3] = 0.000000. Thread # 0
</p>
<p>Checkpoint 2: b[0] = 0.000000. Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Como era de esperar solo se usan los threads 0 y 1, quienes conforman el <i>team</i>. En el <b>checkpoint 1</b> vemos que el orden de la variable <b>i</b>, que va de 1 a 5 no está determinado, mientras que en el <b>checkpoint 2</b>, que es cuando acaba el bloque a paralelizar, el valor del thread es de nueva cuenta el mismo hasta antes de entrar: 0.
</p>


<hr size="6">
<a name="node_005fsubsection_005f1_005f2_005f2"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f2_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f2_005f3" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f2" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-2_002e1"></a>
<h3 class="subsection">1.2.2 Ejemplo 2.1</h3>

<p>El siiguiente ejemplo demuestra porque la sincronización es díficil de implementar correctamente sobre las variables. El valor de la variable <b>flag</b> es indefinida en los <b>checkpoint 2</b> y <b>checkpoint 3</b> en el thread #1 y el valor de la variable <b>data</b> está únicamente bien definida en el <b>checkpoint 3</b>.
</p>
<p>Abordemos este ejemplo propuesto en la documentación, pero primero sin la sintaxis de OpenMP:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{

int x;
x = 2;

{
    if(omp_get_thread_num() == 0)
    {
        x = 5;
        printf(&quot;Checkpoint 1: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
    
        printf(&quot;Checkpoint 2: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    
    }
    
    if(omp_get_thread_num() == 0)
    {
         printf(&quot;Checkpoint 3: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
         printf(&quot;Checkpoint 4: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
}
return 0;
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: Thread # 0: x = 5
</p>
<p>Checkpoint 3: Thread # 0: x = 5
</p>
<p><b>Análisis y conclusión</b>
Como no está paralelizado sólo el thread #0 trabaja el el script de manera secuencial, de modo que sólo los <b>checkpoint 1</b> y <b>checkpoint 3</b> serán impresos. Y dado que se el thread pasa por el <b>checkpoint 1</b> el valor de la variable <b>x</b> cambia a 5.
</p>
<p><b>Ahora vamos a paralelizar este mismo ejemplo pero con 6 threads</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{

int x;
x = 2;

#pragma omo parallel num_threads(6) 
{
    if(omp_get_thread_num() == 0)
    {
        x = 5;
        printf(&quot;Checkpoint 1: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
    
        printf(&quot;Checkpoint 2: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    
    }
    
    if(omp_get_thread_num() == 0)
    {
         printf(&quot;Checkpoint 3: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
         printf(&quot;Checkpoint 4: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
}
return 0;
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: Thread # 0: x = 5
</p>
<p>Checkpoint 3: Thread # 0: x = 5
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Se distribuyeron 6 threads pero, cómo sólo está considerando básicamente dos posibilidades: o es thread #0 u otro thread, pues están inutilizados 4 threads. De modo que ésta es una mala configuración. Lo mejor es configurar a 2. Pero además cómo el primer thread que es lanzado es el thread #0, se imprime el <b>checkpoint 1</b>, y por lo tanto también el <b>checkpoint 2</b>.
</p>
<p><b>Luego del ejemplo anterior, configuramos la paralelización a 2 threads para que sea más optima. Pero ademas agregamos la cláusula <i>shared</i>. Esto garantizará que todos los threads pueden &quot;ver&quot; el valor de las demás variables que son trabajadas por los demás threads</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{

int x;
x = 2;

#pragma omo parallel num_threads(2) shared(x)
{
    if(omp_get_thread_num() == 0)
    {
        x = 5;
        printf(&quot;Checkpoint 1: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
    
        printf(&quot;Checkpoint 2: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    
    }
    
    if(omp_get_thread_num() == 0)
    {
         printf(&quot;Checkpoint 3: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
         printf(&quot;Checkpoint 4: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
}
return 0;
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: Thread # 0: x = 5
</p>
<p>Checkpoint 3: Thread # 0: x = 5
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Por default cuando se paraleliza un bloque, en éste las variables son <i>shared</i>, lo que significa que los valores de las variables son visibles para todos los threads. Por lo que el uso de <i>shared</i> en este ejemplo subraya que la variable <b>x</b> es compartida. De modo que el resultado del ejemplo no es diferente al anterior. Pero sí es más óptimo al usar el número de threads adecuado.
</p>
<p><b>Finalmente agregamos al ejemplo la directiva <i>barrier</i></b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{

int x;
x = 2;

#pragma omo parallel num_threads(2) shared(x)
{
    if(omp_get_thread_num() == 0)
    {
        x = 5;
        printf(&quot;Checkpoint 1: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
    
        printf(&quot;Checkpoint 2: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    
    }
    
    #pragma omp barrier
    if(omp_get_thread_num() == 0)
    {
         printf(&quot;Checkpoint 3: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
    else 
    {
         printf(&quot;Checkpoint 4: Thread # %d: x = %d\n\n&quot;, omp_get_thread_num(), x);
    }
}
return 0;
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: Thread # 0: x = 5
</p>
<p>Checkpoint 3: Thread # 0: x = 5
</p>
<p><b>Análisis y conclusión</b>
</p>

<p>En conclusión general tenemos en las distintas variantes que en el <b>checkpoint 2</b>, el valor de <b>x</b> podría ser 2 o 5, dependiendo de la sincronización de los subprocesos y la implementación de la asignación a la variable <b>x</b>. Hay dos razones por las cuales el valor en <b>checkpoint 2</b> podría no ser 5. Primero, <b>checkpoint 2</b> podría ejecutarse antes de que se ejecute la asignación a la variable <b>x</b>. En segundo lugar, incluso si el <b>checkpoint 2</b> se ejecuta después de la asignación, el thread #1 no garantiza que el valor de 5 sea visto porque el thread #0 puede no haber ejecutado desde la asignación.
</p>
<p>La directiva <i>barrier</i> después de <b>checkpoint 2</b> contiene de manera inplícita directivas <i>flush</i> en todos los threads, una sincronización de threads, por lo que el programador tiene garantizado que el valor de 5 será impreso por los <b>checkpoint 3</b> y <b>checkpoint 4</b>.
</p><hr size="6">
<a name="node_005fsubsection_005f1_005f2_005f3"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f2_005f2" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f3" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f2" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-2_002e3"></a>
<h3 class="subsection">1.2.3 Ejemplo 2.3</h3>
<p>En el siguiente ejemplo  es una muestra del porqué la sincronización es dificil de realizar correctamente a través de variables. Aquí se presenta la secuencia <i>write(1)-flush(1)-flush(2)-read(2)</i> que  como puede verse a lo largo del análisis del ejemplo, los distintos resultados evidencían los problemas de sincronización.
</p>
<p>Revisemos el siguiente ejemplo sin usar la sintaxis de OpenMP:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
    
    int flag = 0;
    
    printf(&quot;Checkpoint 1: Thread # %d: flag = %d\n\n&quot;, omp_get_thread_num(), flag);
    {
    printf(&quot;Checkpoint 2: Thread # %d: flag = %d\n\n&quot;, omp_get_thread_num(), flag);
    
    if(omp_get_thread_num()==0)
    {
        flag++;
        
        printf(&quot;Checkpoint 3: Thread # %d: flag = %d\n\n&quot;, omp_get_thread_num(), flag);
    }
    else if(omp_get_thread_num()==1)
    {
    
        printf(&quot;Checkpoint 4: Thread # %d: flag = %d\n\n&quot;, omp_get_thread_num(), flag);

    flag++;

    printf(&quot;Checkpoint 5: Thread # %d: flag = %d\n\n&quot;, omp_get_thread_num(), flag);
    }
    
    else if(omp_get_thread_num()==2)
    {
            
        printf(&quot;Checkpoint 6: Thread # %d: flag = %d\n\n&quot;, omp_get_thread_num(), flag);
    }
    }
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 3: flag = 1: Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Como sólo hay un thread en el prooeso, el #0, implica que sólo los <b>checkpoint 1</b>, <b>2</b> y <b>3</b> serán ejecutados.
</p>
<p><b>Ahora incluimos en el ejercicio la directiva de paralelización <i>parallel</i> configurado para 3 threads: <i>#pragma omp parallel num_threads(3)</i></b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
    
    int flag = 0;
    
    printf(&quot;Checkpoint 1: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

    #pragma omp parallel num_threads(3)
    {
        printf(&quot;Checkpoint 2: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
        
        if(omp_get_thread_num()==0)
        {
            flag++;
            
            printf(&quot;Checkpoint 3: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
        }
        else if(omp_get_thread_num()==1)
        {
            
            printf(&quot;Checkpoint 4: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

            flag++;

            printf(&quot;Checkpoint 5: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
        }
        
        else if(omp_get_thread_num()==2)
        {
                
            printf(&quot;Checkpoint 6: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

        }
    }
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 1
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 2
</p>                                  
<p>Checkpoint 6: flag = 1: Thread # 2
</p>                                  
<p>Checkpoint 4: flag = 1: Thread # 1
</p>                                  
<p>Checkpoint 5: flag = 2: Thread # 1
</p>                                  
<p>Checkpoint 3: flag = 1: Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Antes de la paralelización sólo hay un thread, el #0. Por lo que en el <b>checkpoint 1</b> sólo es ejecutado por ese thread. 
</p>
<p>Luego inicia el bloque de paralelización con 3 treads: #0, #1 y #2, por lo que son registrados por el <b>checkpoint 2</b>.
</p>
<p>El último thread en salir del <b>checkpoint 2</b> fue el thread #2, por lo que sigue su camino con el valor de la variable que tiene registrada: flag = 0. Su camino continúa hasta el condicional <i>omp_get_thread_num()==2</i> para imprimir el valor de flag = 1 en el <b>checkpoint 6</b>. Ahí termina la vida de ese thread.
</p>
<p>Por otro lado el thread #1 entra al <b>checkpoint 4</b> con el valor de flag = 1, luego aumenta el valor de la variable flag a flag = 2, que es registrada por el <b>checkpoint 5</b>.
</p>
<p>Finalmente el thread #0 llevaba el valor de flag = 0, entra al codicional <i>omp_get_thread_num()==0</i> y cambia el valor de flag a flag = 1.
</p>
<p>Es notorio que cada thread tiene valores diferentes para la variable flag, pues sus caminos dentro del script son distintos y no se comunican entre ellas el cambio de valor que van adquiriendo.
</p>
<p><b>Ahora revisemos el comportamiento del script agregando la primera directiva <i>atomic</i> con su cláusula <i>update</i></b>:
</p>

<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
    int flag = 0;
    
    printf(&quot;Checkpoint 1: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

    #pragma omp parallel num_threads(3)
    {
    printf(&quot;Checkpoint 2: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    
    if(omp_get_thread_num()==0)
    {
        #pragma omp atomic update
        flag++;
        
        printf(&quot;Checkpoint 3: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    else if(omp_get_thread_num()==1)
    {
        printf(&quot;Checkpoint 4: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

        flag++;

        printf(&quot;Checkpoint 5: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    
    else if(omp_get_thread_num()==2)
    {
           
        printf(&quot;Checkpoint 6: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    }
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 2
</p>                                  
<p>Checkpoint 6: flag = 1: Thread # 2
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 1
</p>                                  
<p>Checkpoint 4: flag = 1: Thread # 1
</p>                                  
<p>Checkpoint 5: flag = 2: Thread # 1
</p>                                  
<p>Checkpoint 3: flag = 1: Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Antes de comenzar revisemos que lo que significa para la programación en general lo qué es una <b>variable atómica</b>: una operación atómica consiste en utilizar mecanismos de sincronización para asegurarse de que la operación sea visible, desde cualquier otro thread, como una operación única, atómica (es decir, no se puede dividir en partes). Eso significa que cualquier otro thread, una vez que la operación se haga atómica, verá el valor de de la variable antes o después de la asignación. Pero nunca el valor intermedio. Si no fuese la variable atómica significaría que otro thread puede leer el valor de dicha variable y ver el estado intermedio. Así, las operaciones atómicas son operaciones que no deben ser realizadas por dos hilos simultáneamente.
</p>
<p>El <b>checkpoint 1</b> registra el therad inicial, el thread #0. En seguida se paraleliza el bloque por lo que en el <b>checkpoint 2</b> se tienen los threads #0, #1, y #2 con <b>flag = 0</b>. El <b>checkpoint 3</b> registra la actualización de la variable flag a <b>flag = 1</b> y es actualizada para todos los threads. A partir de aquí todos los threads estan enterados de la actualización. Así, el thread #2 registra el valor actualizado de <b>flag = 1</b> en el <b>checkpoint 6</b>. Y finalmente el thread #1 entra al <b>checkpoint 4</b> con un valor de <b>flag = 1</b> y es postincrementado en 1, por lo que finalmente el <b>checkpoint 5</b> registra un valor de <b>flag = 2</b>.
</p>
<p><b>Ahora revisemos el comportamiento del script agregando la segunda directiva <i>atomic</i></b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
    
    int flag = 0;
    
    printf(&quot;Checkpoint 1: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

    #pragma omp parallel num_threads(3)
    {
    printf(&quot;Checkpoint 2: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    
    if(omp_get_thread_num()==0)
    {
        #pragma omp atomic update
        flag++;
        
        printf(&quot;Checkpoint 3: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    else if(omp_get_thread_num()==1)
    {
        printf(&quot;Checkpoint 4: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

        #pragma omp atomic update
        flag++;

        printf(&quot;Checkpoint 5: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    
    else if(omp_get_thread_num()==2)
    {
           
        printf(&quot;Checkpoint 6: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    }
}
</pre><p><b>Resultados</b>
</p>
<p>Checkpoint 1: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 1
</p>                                  
<p>Checkpoint 3: flag = 1: Thread # 0
</p>                                  
<p>Checkpoint 4: flag = 1: Thread # 1
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 2
</p>                                  
<p>Checkpoint 6: flag = 2: Thread # 2
</p>                                  
<p>Checkpoint 5: flag = 2: Thread # 1
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>El <b>checkpoint 1</b> recibe a un único thread, el #0. Luego pasa al bloque de paralelización y los  threads #1, #2 y #3 acarrean el valor de la variable <b>flag = 0</b> que es registrado por el <b>checkpoint 2</b>. El thread #0 es condicionado y postincrementa su valor en 1 adquiriendo la variable <b>flag = 1</b> y es actualizada para todos los threads mediante el constructor <i>atomic update</i>, mismo que es registrado por los <b>checkpoint 3</b> y <b>checkpoint 4</b>. Inmediatamente es postincrementada la variable a <b>flag = 2</b> y es registrada por los <b>checkpoint 5</b> y <b>checkpoint 6</b>.
</p>
<p><b>Agregamos el primer subloque de <i>flush</i></b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
    
    int flag = 0;
    
    printf(&quot;Checkpoint 1: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    #pragma omp parallel num_threads(3)
    {
    printf(&quot;Checkpoint 2: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    
    if(omp_get_thread_num()==0)
    {
        #pragma omp atomic update
        flag++;
        
    printf(&quot;Checkpoint 3: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    else if(omp_get_thread_num()==1)
    {
    
        #pragma omp flush(flag)
        while(flag &lt; 1)
        {
            #pragma omp flush(flag)
        }
        printf(&quot;Checkpoint 4: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

        #pragma omp atomic update
        flag++;

        printf(&quot;Checkpoint 5: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    
    else if(omp_get_thread_num()==2)
    {
        printf(&quot;Checkpoint 6: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    }
}
</pre><p><b>Resultados</b>
</p>
<p>Checkpoint 1: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 3: flag = 1: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 1: Thread # 2
</p>                                  
<p>Checkpoint 6: flag = 1: Thread # 2
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 1
</p>                                  
<p>Checkpoint 4: flag = 1: Thread # 1
</p>                                  
<p>Checkpoint 5: flag = 2: Thread # 1
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Como ya hemos vismo el <b>checkpoint 1</b> recibe el thread #0, y se procede a entrar al bloque de paralelización. Veamos cómo el <b>checkpoint 2</b> registra el valor de <b>flag = 1</b> cuando apenas  el thread #0 ha entrado a la zona de paralelización, pero aún no a la zona de postincremento de la variable. Esto es debido a que el thread #0 ya registró con unos instantes antes el valor de <b>flag = 1</b> e hizo un <i>atomic update</i> que le avisa a todos los demás threads del nuevo valor. El thread #1 con el valor del <b>flag =1</b> registra este valor en el <b>checkpoint 4</b> realiza un <i>atomic update</i> y luego un post incremento que se verá reflejado en el <b>checkpoint 5</b>.
</p>
<p>El thread #1 registra el valor de <b>flag = 1</b> que es registrado por el <b>checkpoint 4</b> inmediatamente después hay un postincremento que es registrado por el <b>checkpoint 5</b> con <b>flag = 2</b>. 
</p>
<p>La importancia de la directiva <i>flush</i> es que resuelve la consistencia, al exportar a todos los threads un valor modificado de una variable que ha realizado otro hilo en el procesamiento paralelo.
</p>
<p>Finalmente analizamos con todas las directivas y cláusulas. Con el que esperamos que haya consistencia del valor de la variable <i>flag</i>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

int main()
{
    
    int flag = 0;
    
    printf(&quot;Checkpoint 1: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    #pragma omp parallel num_threads(3)
    {
    printf(&quot;Checkpoint 2: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    
    if(omp_get_thread_num()==0)
    {
        #pragma omp atomic update
        flag++;
        
    printf(&quot;Checkpoint 3: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    else if(omp_get_thread_num()==1)
    {
    
        #pragma omp flush(flag)
        while(flag &lt; 1)
        {
            #pragma omp flush(flag)
        }
    printf(&quot;Checkpoint 4: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());

    #pragma omp atomic update
    flag++;

    printf(&quot;Checkpoint 5: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    
    else if(omp_get_thread_num()==2)
    {
        #pragma omp flush(flag)
        while(flag &lt; 2)
        {
            #pragma omp flush(flag)
        }
        
    printf(&quot;Checkpoint 6: flag = %d Thread # %d\n\n&quot;, flag, omp_get_thread_num());
    }
    }
}
</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 0
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 1
</p>                                  
<p>Checkpoint 2: flag = 0: Thread # 2
</p>                                  
<p>Checkpoint 4: flag = 1: Thread # 1
</p>                                  
<p>Checkpoint 5: flag = 2: Thread # 1
</p>                                  
<p>Checkpoint 6: flag = 2: Thread # 2
</p>                                  
<p>Checkpoint 3: flag = 1: Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Queda en evidencia que efectivamente lograr la sincronización de las variables es un trabajo que debe de hacerse con mucho cuidado. En este ejemplo se muestra que para que sea posible, se deben de utilizar las directivas <i>atomic update</i> así como <i>flush</i>. <i>atomic update</i> se utiliza para sincronizar variables escalares en las que interviene el incremento, mientras que <i>flush</i> para cada cuando se trabaja con varios threads en los que es necesario tener presente cómo cambian los valores de las variables en los distintos caminos que sigue cada thread.
</p>

<hr size="6">
<a name="node_005fsection_005f1_005f3"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f2_005f3" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f3_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Compilacion"></a>
<h2 class="section">1.3 Compilación</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f1_005f3_005f1">1.3.1 Ejemplo 3.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f1_005f3_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f3" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f1_005f3" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-3_002e1"></a>
<h3 class="subsection">1.3.1 Ejemplo 3.1</h3>


 
<hr size="6">
<a name="node_005fchapter_005f2"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f1_005f3_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f2_005f4" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f1" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Directivas"></a>
<h1 class="chapter">2. Directivas</h1>
                                                
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsection_005f2_005f4">2.1 Flush</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Directiva Flush                          
</td></tr>
</table>
                                      
                                                
<hr size="6">
<a name="node_005fsection_005f2_005f4"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f2_005f4_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Flush"></a>
<h2 class="section">2.1 Flush</h2>

<p>La directiva <b>flush</b> resuelve la consistencia entre variables al exportar a todos los threads un valor modificado de una variable que ha realizado otro thread en el procesamiento paralelo. Es decir, para cuando el thread llega a la directiva flush, la información del valor de esa variable se exporta al resto de los threads generando con esto consistencia entre los threads. De manera que, esta directiva asegura que las modificaciones hechas por un thread sean efectivas.
</p>
<p>Si <i>flush</i> se aplica a todas las variables podría ser muy costoso en términos de rendimiento.
</p>
<p>Está directiva está presente <b>implícitamente</b> en las siguientes directivas:
</p><ul>
<li> <i>barrrier</i>,
</li><li> <i>critical</i>,
</li><li> <i>ordered</i>, 
</li><li> <i>parallel</i>,
</li><li> <i>parallel for</i>,
</li><li> <i>parallel sections</i>,
</li><li> <i>parallel workshare</i>,
</li><li> <i>atomic</i>
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f2_005f4_005f1">2.1.1 Ejemplo 2.2</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> Ejemplo 2.2c
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f2_005f4_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f2_005f4" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f2_005f4" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Cap&iacute;tulo siguiente"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-2_002e2"></a>
<h3 class="subsection">2.1.1 Ejemplo 2.2</h3>

<p><b>Este ejemplo se ejecuta primero sin la sintaxis de OpenMP.</b>
</p>
<pre class="verbatim">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int data;
    int flag=0;
    
    {
        if (omp_get_thread_num() ==0)	
           {
                data = 42;
       
    	        flag = 1;
    
    	        printf(&quot;Checkpoint 1: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
        
            }

        else if(omp_get_thread_num() == 1)
        
            {
    	        printf(&quot;Checkpoint 2: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
    
    	        printf(&quot;Checkpoint 3: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
            }
    }
    return 0;
}
</pre>
<p><b>Obteniendo los siguientes resultados</b>:
</p>
<p>Checkpoint 1: flag=1 data=42. Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Este ejemplo solo utilza dos threads, en caso de que se declaracen más sólo filtraría el thread # 0 y el thread # 1. De modo que no tiene sentido usar más hilos que los necesarios. 
</p>
<p>Por otro lado, vemos que sólo imprimió el <b>checkpoint 1</b>, y la razón es simple: sin paralelizar el &quot;thread maestro&quot; es el thread # 0. Así que con esta configuración solo se imprimira el <b>checkpoint 1</b> y nunca se imprimira el <b>checkpoint 2</b> ni el <b>checkpoint 3</b>. 
</p>
<p><b>Ahora ejecutamos el mismo ejemplo, pero sólo con la directiva <i>parallel.</i> y para que trabaje con 2 threads</b>
</p><pre class="verbatim">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int data;
    int flag=0;
    
    #pragma omp parallel num_threads(2)
    {
        if (omp_get_thread_num() ==0)	
           {
                data = 42;
       
    	        flag = 1;
    
    	        printf(&quot;Checkpoint 1: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
            }
        else if(omp_get_thread_num() == 1)
        
            {
    	        printf(&quot;Checkpoint 2: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
    
            }
    }
    return 0;
}
</pre>
<p><b>Resultados</b>:
</p>
<p>Checkpoint 1: flag=1 data=42. Thread # 0
</p>
<p>Checkpoint 2: flag=1 data=42. Thread # 1
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Dado que se configuró el bloque a paralelizar con dos threads, los únicos threads presentes son el # 0 y el # 1.
</p>
<p>En el <b>checkpoint 1</b> vemos que dado que se cumple la condición se establecen los valores de las variables como es esperado. Por lo que el <b>checkpoint 2</b> imprime lo esperado.
</p>
<p><b>Finalmente usamos todas las directivas propuestas de OpenMP en el ejemplo. Tanto <i>parallel</i> como <i>flush</i></b>:
</p><pre class="verbatim">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int data;
    int flag=0;
    
    #pragma omp parallel num_threads(2)
    {
        if (omp_get_thread_num() ==0)	
           {
                data = 42;
       
                #pragma omp flush(flag, data)
               
    	        flag = 1;
    
    	        printf(&quot;Checkpoint 1: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
                #pragma omp flush(flag)
        
            }
        else if(omp_get_thread_num() == 1)
        
            {
                #pragma omp flush(flag,data)
                
                while(data &lt; 1)
            
                    {
                        #pragma omp flush(flag, data)	
                    }
    
    	        printf(&quot;Checkpoint 2: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
    
                #pragma omp flush(flag, data)
    
    	        printf(&quot;Checkpoint 3: flag=%d data=%d. Thread # %d\n\n&quot;, flag, data, omp_get_thread_num());
            }
    }
    return 0;
}
</pre>
<p><b>Resultados</b>:
</p>
<p>Checkpoint 1: flag=1 data=42. Thread # 0
</p>
<p>Checkpoint 2: flag=1 data=42. Thread # 1
</p>
<p>Checkpoint 3: flag=1 data=42. Thread # 1
</p>
<hr size="6">
<a name="node_005fchapter_005f3"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f2_005f4_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f2" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Top" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Clausulas"></a>
<h1 class="chapter">3. Clausulas</h1>
                                                
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsection_005f3_005f1">3.1 Private</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Clausula Private                           
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsection_005f3_005f2">3.2 Firstprivate</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Clausula Firstprivate                           
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsection_005f3_005f3">3.3 Lastprivate</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Clausula Lastpirstprivate                           
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsection_005f3_005f4">3.4 Reduction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Clausula Reduction                           
</td></tr>
</table>
                                      

<hr size="6">
<a name="node_005fsection_005f3_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f1_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Private"></a>
<h2 class="section">3.1 Private</h2>

<p>Como puede verse en los siguientes ejemplos, la clausula <b>private</b> no inicializa la lista de variables dentro del bloque a paralelizar, mientras que la clausula <b>firstprivate</b> retoma el valor que tiene cada una de las variables antes del bloque.
</p>
<p>De modo que:
</p>
<p><b>private(valor-i_1, ..., valor-i_N)</b>: Los datos de la región paralela nombrados por private son copiados al área de almacenamiento local del hilo (principalmente su pila), lo que significa que cada hilo los usará como variable temporal. Una variable privada no es inicializada y tampoco se mantiene fuera de la región paralela. Por definición, el contador de iteraciones en OpenMP es privado.
</p>
<p><b>firstprivate(valor-i_1, ..., valor-i_N)</b>: Cada hilo tiene una copia local del dato. La copia local se inicializa con el valor de la copia global en el momento de encontrarse con la directiva a la que se aplica la cláusula.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f3_005f1_005f1">3.1.1 Ejemplo 35.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f3_005f1_005f2">3.1.2 Ejemplo 35.2</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f3_005f1_005f3">3.1.3 Ejemplo 35.3</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f3_005f1_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f1_005f2" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-35_002e1"></a>
<h3 class="subsection">3.1.1 Ejemplo 35.1</h3>

<p><b>Como en los ejemplos anteriores ejecutamos este ejemplo sin la sintaxis de OpenMP</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int i, j;
    int *ptr_i, *ptr_j;
    
    i = 1;
    j = 2;
    
    ptr_i = &amp;i;
    ptr_j = &amp;j;
    
    printf(&quot;Checkpoint 1: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());

    i = 3;
    j = j + 2;
    printf(&quot;Checkpoint 2: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());

    return 0;
}
</pre>
<p><b>Resultado</b>:
</p>
<p>Checkpoint 1: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=3 y j=4. Thread #: 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Este resultado no nos sorprende, pues simplemente se imprimen los valores de las variables de manera secuencial. En adelante el análisis es más interesante.
</p>
<p><b>Ahora incluimos en nuestro ejemplo la directiva <i>parallel omp</i> y configuramos para 8 threads</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int i, j;
    int *ptr_i, *ptr_j;
    
    i = 1;
    j = 2;
    
    ptr_i = &amp;i;
    ptr_j = &amp;j;
    
    printf(&quot;Checkpoint 1: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());

    #pragma omp parallel num_threads(8) 

    {
        printf(&quot;Checkpoint 2: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
        i = 3;
        j = j + 2;
        printf(&quot;Checkpoint 3: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    }

    printf(&quot;Checkpoint 4: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    return 0;
}
</pre>
<p><b>Resultado</b>:
</p>
<p>Checkpoint 1: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 2
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 6
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 5
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 7
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 7
</p>
<p>Checkpoint 3: i=3 y j=8. Thread #: 0
</p>
<p>Checkpoint 3: i=3 y j=6. Thread #: 5
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=12. Thread #: 6
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 1
</p>
<p>Checkpoint 3: i=3 y j=14. Thread #: 1
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 3
</p>
<p>Checkpoint 3: i=3 y j=16. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=18. Thread #: 3
</p>
<p>Checkpoint 3: i=3 y j=10. Thread #: 2
</p>
<p>Checkpoint 4: i=3 y j=18. Thread #: 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>El <b>checkpoint 1</b> como se encuentra antes de entrar al bloque a paralelizar, utiliza el thread #0; y adquiere los valores de las variables <b>i</b> y <b>j</b> que se declararon justo unas lineas antes.
</p>
<p>En el <b>checkpoint 2</b> se utilizan del thread #0 al #8, y de nueva cuenta adquiere los valores de las variables <b>i</b> y <b>j</b> que se declararon antes del bloque.
</p>
<p>Luego del <b>checkpoint 2</b> se redefinen las variables <b>i</b> y <b>j</b> a con <b>i = 3</b> y <b>j = j +2</b> por lo que cada thread retoma el valor de la redefinición de <b>i</b> y <b>j</b> dando como resultado que en todo el <b>checkpoint 3</b> la variable <b>i</b> se mantenga constate, pero el valor de <b>j</b> se incrementa en 2 por cada thread, por lo que el valor final de <b>j = 18</b>.
</p>
<p>Es notorio que tanto el <b>checkpoint 1</b> como el <b>checkpoint 2</b> están dentro del bloque, por lo que el orden de los threads es de manera desordenada.
</p>
<p>Finalmente en el <b>checkpoint 4</b>, al estar fuera del bloque, se retoma el thread #0. Pero con el valor último de la variable <b>j = 18</b>.
</p>
<p>Obviamente esta es un pésimo uso de las directivas de OpenMp. Y es un claro ejemplo de que para paralelizar un script es necesario tener bien presentes los conceptos de OpenMP.
</p>
<p><b>En el siguiente caso, siguiendo con el mismo ejemplo, vamos a agregar la clausula <i>private</i> para la variable: i</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int i, j;
    int *ptr_i, *ptr_j;
    
    i = 1;
    j = 2;
    
    ptr_i = &amp;i;
    ptr_j = &amp;j;
    
    printf(&quot;Checkpoint 1: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());

    #pragma omp parallel num_threads(8) private(i) 

    {
        printf(&quot;Checkpoint 2: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
        i = 3;
        j = j + 2;
        printf(&quot;Checkpoint 3: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    }

    printf(&quot;Checkpoint 4: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    return 0;
}
</pre>
<p><b>Lo cual nos arrojó los siguientes resultados</b>:
</p>
<p>Checkpoint 1: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 6
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 3
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 1
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 0
</p>
<p>Checkpoint 3: i=3 y j=6. Thread #: 6
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 5
</p>
<p>Checkpoint 3: i=3 y j=8. Thread #: 3
</p>
<p>Checkpoint 3: i=3 y j=12. Thread #: 5
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 7
</p>
<p>Checkpoint 3: i=3 y j=14. Thread #: 7
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 2
</p>
<p>Checkpoint 3: i=3 y j=10. Thread #: 1
</p>
<p>Checkpoint 3: i=3 y j=16. Thread #: 2
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=18. Thread #: 4
</p>
<p>Checkpoint 4: i=1 y j=18. Thread #: 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>De igual manera que en el caso anterior, el <b>checkpoint 1</b> el thread es el #0, y las variables <b>i</b> y <b>j</b> tienen los valores iniciales: <b>i = 1</b> y <b>j = 2</b>.
</p>
<p>Una vez dentro del bloque, el <b>checkpoint 2</b>, haciendo caso de la cláusula <b>privada</b> la variable <b>i</b> se reinicia en este punto con valor <b>i = 0</b>, mentras que la variable <b>j</b> al no ser privada adquiere el valor	que se declaró fuera del bloque. Todo el proceso ocurre usando los threads #0 al #7.
</p>
<p>Luego del <b>checkpoint 2</b> la variable <b>i</b> es redefinida como <b>i = 3</b> por lo que a partir de este punto se mantiene constante este valor. No así como la variable <b>j</b> que al no ser declarada como <i>private</i> toma el valor de <b>j = j + 2</b> de modo que por cada thread (ocho en total) se incrementará el valor en 2. Así, el valor final de la variable <b>j</b> será <b>j = 18</b>. (Sin lugar a dudas esta es también es una mala paralelización).
</p>
<p>En el <b>checkpoint 4</b> se vuelve a trabajar con el thread #0, e <b>i</b> vuelve a tener el valor que tenía antes del bloque.
</p>
<p>Concluimos que esta paralelización no aporta los resultados correctos. Por lo menos para la variable <b>j</b>, pues el valor de la variable <b>i</b> sí es el correcto.
</p>
<p><b>en el siguiente caso en vez de usar la cláusula <i>private</i> usaremos la clausula <b>firstprivate</b> para la variable <b>j</b></b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int i, j;
    int *ptr_i, *ptr_j;
    
    i = 1;
    j = 2;
    
    ptr_i = &amp;i;
    ptr_j = &amp;j;
    
    printf(&quot;Checkpoint 1: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());

    #pragma omp parallel num_threads(8) firstprivate(j) 

    {
        printf(&quot;Checkpoint 2: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
        i = 3;
        j = j + 2;
        printf(&quot;Checkpoint 3: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    }

    printf(&quot;Checkpoint 4: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    return 0;
}
</pre>
<p><b>Resultado</b>:
</p>
<p>Checkpoint 1: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 3
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 1
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 6
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 2
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 6
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 0
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 2
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 1
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 5
</p>
<p>Checkpoint 2: i=1 y j=2. Thread #: 7
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 5
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 7
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 3
</p>
<p>Checkpoint 4: i=3 y j=2. Thread #: 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>El <b>checkpoint 1</b> se comporta tal y como lo deseamos. Y es correcto lo que debe de imprimir en pantalla.
</p>
<p>Para el <b>checkpoint 2</b> la variable <b>i</b> retoma el valor que tiene antes del bloque de paralelización: <b>i = 1</b>.
</p>
<p>Después del <b>checkpoint 2</b> se redefinen las variables. La variable <b>i</b> ahora tiene el valor <b>i = 3</b> y <b>j</b> es <b>j = j + 2</b>. Por lo que el <b>checkpoint 3</b> <b>i</b> mantiene el valor que se redefinió: <b>i = 3</b>. Pero la variable <b>j</b> al ser <i>firstprivate</i> en todos los threads vale: <b>j = 4</b> (j = j + 2 = (2) + 2 = 4) sin incrementarse paulativamente por cada thread.
</p>
<p>Finalmente el <b>checkpoint 4</b> adquiere el valor de la variable <b>i = 3</b> pero el de <b>j = 2</b> es decir, al valor que se tenía antes de paralelizar!! Esto es debido al uso de la cláusula <i>firstprivate</i>. Para que el valor que se tiene al final salga del bloque se tendría que usar  la cláusula <i>lastprivate</i>.
</p>
<p>Concluimos diciendo que esta tampoco en la mejor paralelización, debido a que no se retiene el valor de <b>j</b> al final del script.
</p>
<p><b>Ahora ejecutamos el script usando las cláusulas apropiadas</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

int main()
{
    int i, j;
    int *ptr_i, *ptr_j;
    
    i = 1;
    j = 2;
    
    ptr_i = &amp;i;
    ptr_j = &amp;j;
    
    printf(&quot;Checkpoint 1: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());

    #pragma omp parallel num_threads(8) private(i) firstprivate(j) 

    {
        printf(&quot;Checkpoint 2: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
        i = 3;
        j = j + 2;
        printf(&quot;Checkpoint 3: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    }

    printf(&quot;Checkpoint 4: i=%d y j=%d. Thread #: %d\n\n&quot;, i, j, omp_get_thread_num());
    return 0;
}
</pre>
<p><b>Resultado</b>:
</p>

<p>Checkpoint 1: i=1 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 0
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 7
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 1
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 2
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 3
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 2
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 3
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 0
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 1
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 6
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 6
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 5
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 5
</p>
<p>Checkpoint 2: i=0 y j=2. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 4
</p>
<p>Checkpoint 3: i=3 y j=4. Thread #: 7
</p>
<p>Checkpoint 4: i=1 y j=2. Thread #: 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Después de las dicusiones anteriores debe quedar claro el uso de la directiva y las cláusulas en este ejemplo. Más sin embargo hay que decir que esta tampoco es la mejor paralelización, pues el valor de la variable <b>j</b> al salir de la paralelización no conserva el valor correcto, sino	que se reinicia al valor que tenía antes de la paralelización. Para resolver este problema es necesario revisar una cláusula más: <i>lastprivate</i>.
</p><hr size="6">
<a name="node_005fsubsection_005f3_005f1_005f2"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f1_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f1_005f3" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-35_002e2"></a>
<h3 class="subsection">3.1.2 Ejemplo 35.2</h3>

<p><b>Ejecutamos el ejemplo comentando la sintáxis de OpenMp:</b> 
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void g(int k); 
void f(int n);
int a;

int main()
{
    int k = 3;
    int n = 48;
    g(k); 
    f(n);
    return 0;
}
   
void g(int k) 
{
    a = k;
}
    
void f(int n)
{
    int a = 0;
    printf(&quot; valor de a antes de entrar en el pragma: %d\n&quot;, a);

    //#pragma omp parallel for private(a)

    for(int i = 1; i &lt; n; i++)
    {
        a = i;
        g(a * 2);
        printf(&quot; valor de a  en el ciclo for: %d\n&quot;, a);
    }
    printf(&quot; valor de a saliendo del pragma: %d\n&quot;, a);
}

</pre>
<p><b>Obteniendo el siguiente resultado</b>
</p>
<p>valor de a antes de entrar en el pragma: 0
</p>
<p>valor de a  en el ciclo for: 1
</p>
<p>valor de a  en el ciclo for: 2
</p>
<p>valor de a  en el ciclo for: 3
</p>
<p>valor de a  en el ciclo for: 4
</p>
<p>valor de a  en el ciclo for: 5
</p>
<p>valor de a  en el ciclo for: 6
</p>
<p>valor de a  en el ciclo for: 7
</p>
<p>valor de a  en el ciclo for: 8
</p>
<p>valor de a  en el ciclo for: 9
</p>
<p>valor de a  en el ciclo for: 10
</p>
<p>valor de a  en el ciclo for: 11
</p>
<p>valor de a  en el ciclo for: 12
</p>
<p>valor de a  en el ciclo for: 13
</p>
<p>valor de a  en el ciclo for: 14
</p>
<p>valor de a  en el ciclo for: 15
</p>
<p>valor de a  en el ciclo for: 16
</p>
<p>valor de a  en el ciclo for: 17
</p>
<p>valor de a  en el ciclo for: 18
</p>
<p>valor de a  en el ciclo for: 19
</p>
<p>valor de a  en el ciclo for: 20
</p>
<p>valor de a  en el ciclo for: 21
</p>
<p>valor de a  en el ciclo for: 22
</p>
<p>valor de a  en el ciclo for: 23
</p>
<p>valor de a  en el ciclo for: 24
</p>
<p>valor de a  en el ciclo for: 25
</p>
<p>valor de a  en el ciclo for: 26
</p>
<p>valor de a  en el ciclo for: 27
</p>
<p>valor de a  en el ciclo for: 28
</p>
<p>valor de a  en el ciclo for: 29
</p>
<p>valor de a  en el ciclo for: 30
</p>
<p>valor de a  en el ciclo for: 31
</p>
<p>valor de a  en el ciclo for: 32
</p>
<p>valor de a  en el ciclo for: 33
</p>
<p>valor de a  en el ciclo for: 34
</p>
<p>valor de a  en el ciclo for: 35
</p>
<p>valor de a  en el ciclo for: 36
</p>
<p>valor de a  en el ciclo for: 37
</p>
<p>valor de a  en el ciclo for: 38
</p>
<p>valor de a  en el ciclo for: 39
</p>
<p>valor de a  en el ciclo for: 40
</p>
<p>valor de a  en el ciclo for: 41
</p>
<p>valor de a  en el ciclo for: 42
</p>
<p>valor de a  en el ciclo for: 43
</p>
<p>valor de a  en el ciclo for: 44
</p>
<p>valor de a  en el ciclo for: 45
</p>
<p>valor de a  en el ciclo for: 46
</p>
<p>valor de a  en el ciclo for: 47
</p>
<p>valor de a saliendo del pragma: 47
</p>

<p><b>Ejecutamos el ejemplo con la sintáxis de OpenMp:</b> 
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void g(int k); 
void f(int n);
int a;

int main()
{
    int k = 3;
    int n = 48;
    g(k); 
    f(n);
    return 0;
}
   
void g(int k) 
{
    a = k;
}
    
void f(int n)
{
    int a = 0;
    printf(&quot;Valor de a antes de entrar en el pragma: %d\n&quot;, a);

    #pragma omp parallel for private(a)

    for(int i = 1; i &lt; n; i++)
    {
        a = i;
        g(a * 2);
        printf(&quot;Valor de a  en el ciclo for: %d\n&quot;, a);
    }
    printf(&quot;Valor de a saliendo del pragma: %d\n&quot;, a);
}

</pre>
<p><b>Obteniendo el siguiente resultado</b>
</p>
<p>Valor de a antes de entrar en el pragma: 0
</p>
<p>Valor de a  en el ciclo for: 36
</p>
<p>Valor de a  en el ciclo for: 39
</p>
<p>Valor de a  en el ciclo for: 45
</p>
<p>Valor de a  en el ciclo for: 44
</p>
<p>Valor de a  en el ciclo for: 30
</p>
<p>Valor de a  en el ciclo for: 24
</p>
<p>Valor de a  en el ciclo for: 2
</p>
<p>Valor de a  en el ciclo for: 40
</p>
<p>Valor de a  en el ciclo for: 4
</p>
<p>Valor de a  en el ciclo for: 26
</p>
<p>Valor de a  en el ciclo for: 42
</p>
<p>Valor de a  en el ciclo for: 3
</p>
<p>Valor de a  en el ciclo for: 6
</p>
<p>Valor de a  en el ciclo for: 43
</p>
<p>Valor de a  en el ciclo for: 31
</p>
<p>Valor de a  en el ciclo for: 8
</p>
<p>Valor de a  en el ciclo for: 28
</p>
<p>Valor de a  en el ciclo for: 9
</p>
<p>Valor de a  en el ciclo for: 34
</p>
<p>Valor de a  en el ciclo for: 41
</p>
<p>Valor de a  en el ciclo for: 7
</p>
<p>Valor de a  en el ciclo for: 33
</p>
<p>Valor de a  en el ciclo for: 11
</p>
<p>Valor de a  en el ciclo for: 5
</p>
<p>Valor de a  en el ciclo for: 21
</p>
<p>Valor de a  en el ciclo for: 20
</p>
<p>Valor de a  en el ciclo for: 12
</p>
<p>Valor de a  en el ciclo for: 15
</p>
<p>Valor de a  en el ciclo for: 18
</p>
<p>Valor de a  en el ciclo for: 23
</p>
<p>Valor de a  en el ciclo for: 47
</p>
<p>Valor de a  en el ciclo for: 22
</p>
<p>Valor de a  en el ciclo for: 37
</p>
<p>Valor de a  en el ciclo for: 35
</p>
<p>Valor de a  en el ciclo for: 38
</p>
<p>Valor de a  en el ciclo for: 14
</p>
<p>Valor de a  en el ciclo for: 19
</p>
<p>Valor de a  en el ciclo for: 27
</p>
<p>Valor de a  en el ciclo for: 32
</p>
<p>Valor de a  en el ciclo for: 25
</p>
<p>Valor de a  en el ciclo for: 16
</p>
<p>Valor de a  en el ciclo for: 13
</p>
<p>Valor de a  en el ciclo for: 29
</p>
<p>Valor de a  en el ciclo for: 17
</p>
<p>Valor de a  en el ciclo for: 10
</p>
<p>Valor de a  en el ciclo for: 1
</p>
<p>Valor de a  en el ciclo for: 46
</p>
<p>Valor de a saliendo del pragma: 0
</p>

<hr size="6">
<a name="node_005fsubsection_005f3_005f1_005f3"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f1_005f2" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f2" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f1" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-35_002e3"></a>
<h3 class="subsection">3.1.3 Ejemplo 35.3</h3>

<p><b>Ejecutamos el ejemplo comentando la sintáxis de OpenMp:</b> 
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void priv_example3();

int main()
{

    priv_example3();
    return 0;

}


void priv_example3()
{

    int i, a;

    //#pragma omp parallel private(a) num_threads(6)
    {
        printf(&quot;Checkpoint 1: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
    
        a = 1;

        printf(&quot;Checkpoint 2: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
        //#pragma omp parallel for private(a)
	for(i = 0; i &lt; 10; i++)
	{
	
            a = 2;	
	
        printf(&quot;Checkpoint 3: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
	}
        //assert(a == 1) ;
        //printf(&quot;Checkpoint 4: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
    }

}

</pre>
<p><b>Obteniendo los siguientes resultados</b>:
</p>
<p>Checkpoint 1: a = 0. Thread #: 0
</p>
<p>Checkpoint 2: a = 1. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 2. Thread #: 0
</p>
<p><b>Ejecutamos el ejemplo con el primer pragma activo</b>: 
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void priv_example3();

int main()
{

    priv_example3();
    return 0;

}


void priv_example3()
{

    int i, a;

    #pragma omp parallel private(a) num_threads(6)
    {
        printf(&quot;Checkpoint 1: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
    
        a = 1;

        printf(&quot;Checkpoint 2: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
        //#pragma omp parallel for private(a)
	for(i = 0; i &lt; 10; i++)
	{
	
            a = 2;	
	
        printf(&quot;Checkpoint 3: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
	}
        //assert(a == 1) ;
        printf(&quot;Checkpoint 4: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
    }

}

</pre>
<p><b>Obteniendo los siguientes resultados</b>:
</p>
<p>Checkpoint 1: a = 0. Thread #: 0
</p>
<p>Checkpoint 2: a = 1. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 2. Thread #: 0
</p>
<p>Checkpoint 1: a = 0. Thread #: 3
</p>
<p>Checkpoint 2: a = 1. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 3
</p>
<p>Checkpoint 1: a = 0. Thread #: 5
</p>
<p>Checkpoint 2: a = 1. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 5
</p>
<p>Checkpoint 1: a = 0. Thread #: 1
</p>
<p>Checkpoint 2: a = 1. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 1
</p>
<p>Checkpoint 1: a = 0. Thread #: 2
</p>
<p>Checkpoint 2: a = 1. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 2
</p>
<p>Checkpoint 4: a = 2. Thread #: 2
</p>
<p>Checkpoint 1: a = 0. Thread #: 4
</p>
<p>Checkpoint 4: a = 2. Thread #: 3
</p>
<p>Checkpoint 2: a = 1. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 4: a = 2. Thread #: 5
</p>
<p>Checkpoint 4: a = 2. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 3: a = 2. Thread #: 4
</p>
<p>Checkpoint 4: a = 2. Thread #: 4
</p>
<p><b>Ejecutamos el ejemplo con ambos pragmas activos</b>: 
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void priv_example3();

int main()
{

    priv_example3();
    return 0;

}


void priv_example3()
{

    int i, a;

    #pragma omp parallel private(a) num_threads(6)
    {
        printf(&quot;Checkpoint 1: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
    
        a = 1;

        printf(&quot;Checkpoint 2: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
        #pragma omp parallel for private(a)
	for(i = 0; i &lt; 10; i++)
	{
	
            a = 2;	
	
        printf(&quot;Checkpoint 3: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
	}
        //assert(a == 1) ;
        printf(&quot;Checkpoint 4: a = %d. Thread #: %d\n\n&quot;, a, omp_get_thread_num());
    }

}

</pre>
<p><b>Obteniendo los siguientes resultados</b>:
</p>
<p>Checkpoint 1: a = 0. Thread #: 0
</p>
<p>Checkpoint 2: a = 1. Thread #: 0
</p>
<p>Checkpoint 1: a = 0. Thread #: 1
</p>
<p>Checkpoint 2: a = 1. Thread #: 1
</p>
<p>Checkpoint 1: a = 0. Thread #: 2
</p>
<p>Checkpoint 2: a = 1. Thread #: 2
</p>
<p>Checkpoint 1: a = 0. Thread #: 3
</p>
<p>Checkpoint 2: a = 1. Thread #: 3
</p>
<p>Checkpoint 1: a = 0. Thread #: 4
</p>
<p>Checkpoint 2: a = 1. Thread #: 4
</p>
<p>Checkpoint 1: a = 0. Thread #: 5
</p>
<p>Checkpoint 2: a = 1. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 1. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 1. Thread #: 1
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 1. Thread #: 3
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 1. Thread #: 5
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 1. Thread #: 2
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 3: a = 2. Thread #: 0
</p>
<p>Checkpoint 4: a = 1. Thread #: 4
</p>
<hr size="6">
<a name="node_005fsection_005f3_005f2"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f1_005f3" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f2_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Firstprivate"></a>
<h2 class="section">3.2 Firstprivate</h2>

<p>firstprivate(valor-i_1, ..., valor-i_N): Cada hilo tiene una copia local del dato. La copia local se inicializa con el valor de la copia global en el momento de encontrarse con la directiva a la que se aplica la cláusula.
</p>
<p>Esta clausula declara privadas las variables de la lista y además las inicializa a sus valores anteriores (valores en el master). Las variables globales son recogidas por el master.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f3_005f2_005f1">3.2.1 Ejemplo 37.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f3_005f2_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f2" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f3" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f2" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-37_002e1"></a>
<h3 class="subsection">3.2.1 Ejemplo 37.1</h3>

<p><b>Se ejecuto en un primer momemnto sin la sintaxis de OpenMP</b>
</p>
<pre class="verbatim">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void f(int n, int B[n][n], int C[]);

int A[2][2] = {1, 2, 3, 4};

int main()
{

    f(2, A, A[0]);
    return 0;

}

void f(int n, int B[n][n], int C[])
{
    
    int D[2][2] = {1, 2, 3, 4};
    int E[n][n];
    
    assert(n&gt;=2);
    E[1][1] = 4;
    
    printf(&quot;Checkpoint 1: A = %d, B = %d, C = %d, D = %d, E = %d. Hilo# %d\n\n&quot;, A, B, C, D, E, omp_get_thread_num());
    //#pragma omp parallel firstprivate(B, C, D, E) num_threads(8)
    {
    printf(&quot;Checkpoint 2: A = %d, B = %d, C = %d, D = %d, E = %d. Hilo# %d\n\n&quot;, A, B, C, D, E, omp_get_thread_num());
    
        assert(sizeof(B) == sizeof(int (*)[n]));
        assert(sizeof(C) == sizeof(int *));
        assert(sizeof(D) == 4 * sizeof(int));
        assert(sizeof(E) == n * n * sizeof(int));
        
        assert(&amp;B[1][1] == &amp;A[1][1]);
        assert(&amp;C[3] == &amp;A[1][1]);
        assert(D[1][1] == 4);
        assert(E[1][1] == 4);
    
    }
    
    printf(&quot;Checkpoint 3: A = %d, B = %d, C = %d, D = %d, E = %d. Hilo# %d\n\n&quot;, A, B, C, D, E, omp_get_thread_num());
}


</pre>
<p><b>Obteniendo los siguientes resultados</b>:
</p>

<p>Checkpoint 1: A = 1867792464, B = 1867792464, C = 1867792464, D = -1809097120, E = -1809097168. Hilo# 0
</p>
<p>Checkpoint 2: A = 1867792464, B = 1867792464, C = 1867792464, D = -1809097120, E = -1809097168. Hilo# 0
</p>
<p>Checkpoint 3: A = 1867792464, B = 1867792464, C = 1867792464, D = -1809097120, E = -1809097168. Hilo# 0
</p>
<p><b>Luego con OpenMP</b>
</p>

<pre class="verbatim">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

void f(int n, int B[n][n], int C[]);

int A[2][2] = {1, 2, 3, 4};

int main()
{

    f(2, A, A[0]);
    return 0;

}

void f(int n, int B[n][n], int C[])
{
    
    int D[2][2] = {1, 2, 3, 4};
    int E[n][n];
    
    assert(n&gt;=2);
    E[1][1] = 4;
    
    printf(&quot;Checkpoint 1: A = %d, B = %d, C = %d, D = %d, E = %d. Hilo# %d\n\n&quot;, A, B, C, D, E, omp_get_thread_num());
    #pragma omp parallel firstprivate(B, C, D, E) num_threads(8)
    {
    printf(&quot;Checkpoint 2: A = %d, B = %d, C = %d, D = %d, E = %d. Hilo# %d\n\n&quot;, A, B, C, D, E, omp_get_thread_num());
    
        assert(sizeof(B) == sizeof(int (*)[n]));
        assert(sizeof(C) == sizeof(int *));
        assert(sizeof(D) == 4 * sizeof(int));
        assert(sizeof(E) == n * n * sizeof(int));
        
        assert(&amp;B[1][1] == &amp;A[1][1]);
        assert(&amp;C[3] == &amp;A[1][1]);
        assert(D[1][1] == 4);
        assert(E[1][1] == 4);
    
    }
    
    printf(&quot;Checkpoint 3: A = %d, B = %d, C = %d, D = %d, E = %d. Hilo# %d\n\n&quot;, A, B, C, D, E, omp_get_thread_num());
}


</pre>




<p><b>Resultados</b>
</p>
<p>Checkpoint 1: A = 253075552, B = 253075552, C = 253075552, D = -834303568, E = -834303632. Hilo# 0
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -834303776, E = -834303824. Hilo# 0
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -891060752, E = -891060800. Hilo# 4
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -907846160, E = -907846208. Hilo# 6
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -916238864, E = -916238912. Hilo# 7
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -882668048, E = -882668096. Hilo# 3
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -865882640, E = -865882688. Hilo# 1
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -874275344, E = -874275392. Hilo# 2
</p>
<p>Checkpoint 2: A = 253075552, B = 253075552, C = 253075552, D = -899453456, E = -899453504. Hilo# 5
</p>
<p>Checkpoint 3: A = 253075552, B = 253075552, C = 253075552, D = -834303568, E = -834303632. Hilo# 0
</p>

<hr size="6">
<a name="node_005fsection_005f3_005f3"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f2_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f3_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Lastprivate"></a>
<h2 class="section">3.3 Lastprivate</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f3_005f3_005f1">3.3.1 Ejemplo 38.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f3_005f3_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f3" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f4" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f3" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-38_002e1"></a>
<h3 class="subsection">3.3.1 Ejemplo 38.1</h3>

<p><b>Sin la sintaxis de OpenMP</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 50

void lastpriv(int n, float *a, float *b);

int main()
{
    int n = 11;
    float a[TAMANO];
    float b[TAMANO];

    lastpriv(n, a, b);
    return 0;
}


void lastpriv(int n, float *a, float *b)
{
    int i;
    
    #pragma omp parallel num_threads(9)
    {
        #pragma omp for lastprivate(i)
        for(i = 0; i &lt;n-1; i++)
	{
            a[i] = b[i] + b[i+1];
            printf(&quot;Checkpoint 1: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
	}
    }
    
     printf(&quot;Checkpoint 2: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
     a[i] = b[i];
     printf(&quot;Checkpoint 3: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
}


</pre>
<p><b>Resultados</b>
</p>

<p>Checkpoint 1: a[0] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[1] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[2] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[3] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[4] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[5] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[6] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[7] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[8] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[9] = 0.000000. Thread # 0
</p>
<p>Checkpoint 2: a[10] = 0.000000. Thread # 0
</p>
<p>Checkpoint 3: a[10] = 0.000000. Thread # 0
</p>
<p><b>Paralelizando usando parallel omp omp_threads()</b>
</p>

<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 50

void lastpriv(int n, float *a, float *b);

int main()
{
    int n = 11;
    float a[TAMANO];
    float b[TAMANO];

    lastpriv(n, a, b);
    return 0;
}


void lastpriv(int n, float *a, float *b)
{
    int i;
    
    #pragma omp parallel num_threads(9)
    {
        //#pragma omp for lastprivate(i)
        for(i = 0; i &lt;n-1; i++)
	{
            a[i] = b[i] + b[i+1];
            printf(&quot;Checkpoint 1: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
	}
    }
    
     printf(&quot;Checkpoint 2: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
     a[i] = b[i];
     printf(&quot;Checkpoint 3: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
}


</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[1] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[2] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[3] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[4] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[5] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 8
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 7
</p>
<p>Checkpoint 1: a[7] = 0.000000. Thread # 8
</p>
<p>Checkpoint 1: a[8] = 0.000000. Thread # 8
</p>
<p>Checkpoint 1: a[9] = 0.000000. Thread # 8
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 2
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 3
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 6
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 5
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 1
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[6] = 0.000000. Thread # 4
</p>
<p>Checkpoint 2: a[18] = 0.000000. Thread # 0
</p>
<p>Checkpoint 3: a[18] = 0.000000. Thread # 0
</p>

<p><b>Paralelizando hasta omp for</b>
</p>

<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 50

void lastpriv(int n, float *a, float *b);

int main()
{
    int n = 11;
    float a[TAMANO];
    float b[TAMANO];

    lastpriv(n, a, b);
    return 0;
}


void lastpriv(int n, float *a, float *b)
{
    int i;
    
    #pragma omp parallel num_threads(9)
    {
        //#pragma omp for lastprivate(i)
        for(i = 0; i &lt;n-1; i++)
	{
            a[i] = b[i] + b[i+1];
            printf(&quot;Checkpoint 1: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
	}
    }
    
     printf(&quot;Checkpoint 2: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
     a[i] = b[i];
     printf(&quot;Checkpoint 3: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
}


</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a[2] = 0.000000. Thread # 1
</p>
<p>Checkpoint 1: a[0] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[1] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[8] = 0.000000. Thread # 7
</p>
<p>Checkpoint 1: a[6] = 0.000000. Thread # 5
</p>
<p>Checkpoint 1: a[5] = 0.000000. Thread # 4
</p>
<p>Checkpoint 1: a[7] = 0.000000. Thread # 6
</p>
<p>Checkpoint 1: a[9] = 0.000000. Thread # 8
</p>
<p>Checkpoint 1: a[4] = 0.000000. Thread # 3
</p>
<p>Checkpoint 1: a[3] = 0.000000. Thread # 2
</p>
<p>Checkpoint 2: a[0] = 0.000000. Thread # 0
</p>
<p>Checkpoint 3: a[0] = 0.000000. Thread # 0
</p>
<p><b>Paralelizando todo</b>
</p>


<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 50

void lastpriv(int n, float *a, float *b);

int main()
{
    int n = 11;
    float a[TAMANO];
    float b[TAMANO];

    lastpriv(n, a, b);
    return 0;
}


void lastpriv(int n, float *a, float *b)
{
    int i;
    
    #pragma omp parallel num_threads(9)
    {
        //#pragma omp for lastprivate(i)
        for(i = 0; i &lt;n-1; i++)
	{
            a[i] = b[i] + b[i+1];
            printf(&quot;Checkpoint 1: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
	}
    }
    
     printf(&quot;Checkpoint 2: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
     a[i] = b[i];
     printf(&quot;Checkpoint 3: a[%d] = %f. Thread # %d\n\n&quot;, i, a[i], omp_get_thread_num());
}


</pre><p><b>Resultados</b>
</p>


<p>Checkpoint 1: a[0] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[1] = 0.000000. Thread # 0
</p>
<p>Checkpoint 1: a[6] = 0.000000. Thread # 5
</p>
<p>Checkpoint 1: a[4] = 0.000000. Thread # 3
</p>
<p>Checkpoint 1: a[2] = 0.000000. Thread # 1
</p>
<p>Checkpoint 1: a[7] = 0.000000. Thread # 6
</p>
<p>Checkpoint 1: a[9] = 0.000000. Thread # 8
</p>
<p>Checkpoint 1: a[8] = 0.000000. Thread # 7
</p>
<p>Checkpoint 1: a[3] = 0.000000. Thread # 2
</p>
<p>Checkpoint 1: a[5] = 0.000000. Thread # 4
</p>
<p>Checkpoint 2: a[10] = 0.000000. Thread # 0
</p>
<p>Checkpoint 3: a[10] = 0.000000. Thread # 0
</p>


<hr size="6">
<a name="node_005fsection_005f3_005f4"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f3_005f1" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsubsection_005f3_005f4_005f1" title="Secci&oacute;n siguiente en orden de lectura"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Reduction"></a>
<h2 class="section">3.4 Reduction</h2>

<p><b>reduction(tipo:valor-i_1, ..., valor-i_N)</b>: Cada thread privatiza las variables listadas y al finalizar la sección de la directiva en la que aparece la cláusula, los distintos threads actualizan la variable global de la que deriva la copia privada realizando la operación indicada por la clásulua reduction. Esto evita condiciones de carrera. El tipo puede ser: +, -, *, /, min, max ó definido por el usuario.
</p>
<p>Las variables en &quot;valor-i&quot; deben ser compartidas dentro de la región paralela.
</p>
<p>Adentro de parallel o el bloque de construcción de trabajo en paralelo:
</p>
<p>• Se crea una copia privada de cada variable de la lista y se inicializa de acuerdo al valor-i.
</p>
<p>• Estas copias son actualizadas localmente por los threads.
</p>
<p>•Al final del bloque de construcción, las copias locales se combinan de acuerdo al tipo a un solo valor y se almacena en la variable compartida original.
</p>
<p>Se puede especificar más de una operación de reducción.
</p>
<p>El valor de la variable de reducción es indefinido desde el momento que el primer thread alcanza la cláusula hasta que la operación se completa
</p>
<p>Es la aplicación de un operador, puede ser binario conmutativo y asociativo a una variable y algún otro valor, almacenando el resultado en la variable.
</p>
<p>La cláusula reduction especifica un tipo de dato distinto de shared o private.
</p>
<p>Si se utiliza nowait la variable está indefinida hasta la primera barrera de sincronización
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#node_005fsubsection_005f3_005f4_005f1">3.4.1 Ejemplo 39.1</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="node_005fsubsection_005f3_005f4_005f1"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f4" title="Secci&oacute;n anterior en orden de lectura"> &lt; </a>]</td>
<td valign="middle" align="left">[ &gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#node_005fchapter_005f3" title="Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#node_005fsection_005f3_005f4" title="Subir secci&oacute;n"> Subir </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<a name="Ejemplo-39_002e1"></a>
<h3 class="subsection">3.4.1 Ejemplo 39.1</h3>

<p><b>Primero ejecutamos el ejemplo propuesto en la documentación, pero sin paralelizar. Paulatinamente iremos incluyendo la sintaxis de OpenMP</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}

</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[2] = 0.000, b = y[2] = 0, c = y[2] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[3] = 0.000, b = y[3] = 0, c = y[3] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[4] = 0.000, b = y[4] = 841155440, c = y[4] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[5] = 0.000, b = y[5] = 841176807, c = y[5] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[6] = 0.000, b = y[6] = 22071, c = y[6] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[7] = 0.000, b = y[7] = 928, c = y[7] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[8] = 0.000, b = y[8] = 321541808, c = y[8] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[9] = 0.000, b = y[9] = 321530190, c = y[9] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 2: a = x[10] = 0.000, b = y[10] = 321530190, c = y[10] = 0, d = 0.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>En primer lugar vemos que el thread que está presente en todo todos los checkpoints, como es de esperarse, es el thread #0. Además, que de manera secuencial el índice <b>i</b> en el <b>checkpoint 1</b> recorre de 0 a 9. Así en el <b>checkpoint 2</b> el valor de <b>i</b> es 10. 
</p>
<p><b>Ahora vamos a incluir la sintaxis la directiva: #pragma omp  con el constructor <i>parallel</i> y configurado para 10 threads (num_threads(10))</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel num_threads(10) 
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}

</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[2] = -1060001845662973952.000, b = y[2] = 0, c = y[2] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[3] = -1060001845662973952.000, b = y[3] = 0, c = y[3] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[4] = -1060001845662973952.000, b = y[4] = 1002984448, c = y[4] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[5] = -1060001845662973952.000, b = y[5] = 1002963345, c = y[5] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[6] = -1060001845662973952.000, b = y[6] = 20849, c = y[6] = 0, d = 0.006 Thread # 0
</p>
<p>Checkpoint 1: a = x[7] = -1060001845662973952.000, b = y[7] = 1248, c = y[7] = 0, d = 0.006 Thread # 0
</p>
<p>Checkpoint 1: a = x[8] = -1060001845662973952.000, b = y[8] = 2041929072, c = y[8] = 0, d = 0.006 Thread # 0
</p>
<p>Checkpoint 1: a = x[9] = -1060001845662973952.000, b = y[9] = 2041913997, c = y[9] = 0, d = 0.006 Thread # 0
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 3
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 9
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 6
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 2
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 7
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 2: a = x[19] = -1060001845662973952.000, b = y[19] = 2041913997, c = y[19] = 0, d = 0.006 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Una vez que se forma el <i>team</i> dentro del bloque de paralelización se divide entre los threads el número de tareas, de tal modo que el thread #0 tiene la tarea de resolver el <i>for-loop</i> y los demás threads no les queda otra tarea más que tomar la variable <b>i</b> con valor 0. Así el <b>checkpoint 1</b> tiene en total 19 replicas de la variable <b>i</b>, valor que será accarrreado al <b>checkpoint 2</b>, el cual al estar fuera del bloque de paralelización estará a cargo del thread #0. 
</p>
<p>Es obvio que el valor de la variable <b>i</b> en el <b>checkpoint 2</b> no puede ser 19, pero esto es debido a que hay recurrencia de tareas, además de que no se deberíá de acarrerar por estar fuera del bloque de paralelización. Por tal motivo es que es necesario hacer uso de la directiva <i>for</i>.
</p>
<p><b>Ahora incluimos la directiva <i>for</i></b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel for num_threads(10) 
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}

</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a = x[0] = -0.000, b = y[0] = 1216, c = y[0] = -1759092496, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[9] = -0.000, b = y[9] = -1759109361, c = y[9] = -1759092496, d = 0.000 Thread # 9
</p>
<p>Checkpoint 1: a = x[3] = -0.000, b = y[3] = 1216, c = y[3] = -1759092496, d = 0.000 Thread # 3
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 1: a = x[5] = 0.000, b = y[5] = 20862, c = y[5] = -2074230672, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[8] = -0.000, b = y[8] = 326890814, c = y[8] = -2074230672, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[4] = -0.000, b = y[4] = 1216, c = y[4] = -1759092496, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[6] = -0.000, b = y[6] = -1759092496, c = y[6] = -1759092496, d = 0.000 Thread # 6
</p>
<p>Checkpoint 1: a = x[7] = -0.000, b = y[7] = -1759103666, c = y[7] = -1759092496, d = 0.000 Thread # 7
</p>
<p>Checkpoint 1: a = x[2] = 0.000, b = y[2] = 1216, c = y[2] = -1759092496, d = 0.000 Thread # 2
</p>
<p>Checkpoint 2: a = x[0] = 0.000, b = y[0] = 20862, c = y[0] = -2074230672, d = 0.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>Bajo la cláusula <i>for</i> el <i>team</i> se divide la tarea del <i>for-loop</i> entre el total de threads. De modo que todo el <b>checkpoint 1</b> usa todos los threads, y al terminar el bloque de paralelización no se acarrea el valor de la variable <b>i</b> y se regresa al thread #0. 
</p>

<p><b>incluimos la cláusula private</b>:
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel for num_threads(10) private(i) 
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}


</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a = x[2] = -1798088254763891193879113911762944.000, b = y[2] = -942783360, c = y[2] = -1057733520, d = 0.000 Thread # 2
</p>
<p>Checkpoint 1: a = x[4] = 0.000, b = y[4] = -1057734480, c = y[4] = -1057733520, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[6] = 0.000, b = y[6] = -942783360, c = y[6] = -1057733520, d = 0.000 Thread # 6
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 1: a = x[5] = 0.000, b = y[5] = -1057746501, c = y[5] = -1057733520, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[7] = 0.000, b = y[7] = 21963, c = y[7] = 0, d = 0.000 Thread # 7
</p>
<p>Checkpoint 1: a = x[3] = 0.000, b = y[3] = -942783360, c = y[3] = -1057733520, d = 0.000 Thread # 3
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[8] = 0.000, b = y[8] = -1057733520, c = y[8] = -1057733520, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[9] = 0.000, b = y[9] = -1057734833, c = y[9] = -1057733520, d = 0.000 Thread # 9
</p>
<p>Checkpoint 2: a = x[0] = 0.000, b = y[0] = -1057734833, c = y[0] = -1057733520, d = 0.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p>En este ejemplo no hay variación con respecto al ejercicio  anterior, puesto que aunque en este caso se incluye en la cláusula <i>private</i> la variable <b>i</b>, en el caso anterior, la variable <b>i</b> también es implícitamente private, puesto que para OpenMP todo índice en el <i>loop-for</i> se le considera una variable privada.
</p>
<p><b>A la sintaxis se le agrega la cláusula <i>shared</i>, quedando con la siguiente estructura: #pragma omp parallel for num_threads(10) private(i) shared(x, y, n)</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel for num_threads(10) private(i) shared(x, y, n) 
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}
 

</pre>
<p><b>Resultados</b>
</p>

<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[6] = 0.000, b = y[6] = 11994, c = y[6] = 0, d = 0.000 Thread # 6
</p>
<p>Checkpoint 1: a = x[5] = 0.000, b = y[5] = 115064362, c = y[5] = 0, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[7] = 0.000, b = y[7] = 115076045, c = y[7] = 0, d = 0.000 Thread # 7
</p>
<p>Checkpoint 1: a = x[4] = 0.000, b = y[4] = 115076045, c = y[4] = 0, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[2] = 0.000, b = y[2] = 32765, c = y[2] = 0, d = 0.000 Thread # 2
</p>
<p>Checkpoint 1: a = x[9] = 0.000, b = y[9] = 32765, c = y[9] = 0, d = 0.000 Thread # 9
</p>
<p>Checkpoint 1: a = x[8] = 0.000, b = y[8] = 1169025453, c = y[8] = 0, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 115076045, c = y[1] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 1: a = x[3] = 0.000, b = y[3] = 115064362, c = y[3] = 0, d = 0.000 Thread # 3
</p>
<p>Checkpoint 2: a = x[0] = 0.000, b = y[0] = 115076045, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p><b>Ahora incluimos el primer reduction</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel for num_threads(10) private(i) shared(x, y, n) reduction(^:b) 
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}

</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a = x[5] = 0.000, b = y[5] = 21917, c = y[5] = 0, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[6] = -1192137617873368271185678172160.000, b = y[6] = -244268816, c = y[6] = -528276144, d = 0.000 Thread # 6
</p>
<p>Checkpoint 1: a = x[9] = -1192137617873368271185678172160.000, b = y[9] = 32767, c = y[9] = -528276144, d = 0.000 Thread # 9
</p>
<p>Checkpoint 1: a = x[2] = -1192137617873368271185678172160.000, b = y[2] = 0, c = y[2] = -528276144, d = 0.000 Thread # 2
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = -528276144, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[4] = -1192137617873368271185678172160.000, b = y[4] = -244267968, c = y[4] = -528276144, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[3] = -1192137617873368271185678172160.000, b = y[3] = 0, c = y[3] = -528276144, d = 0.000 Thread # 3
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 1: a = x[8] = 0.000, b = y[8] = -528276144, c = y[8] = -528276144, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[7] = 0.000, b = y[7] = 21917, c = y[7] = 0, d = 0.000 Thread # 7
</p>
<p>Checkpoint 2: a = x[0] = -1192137617873368271185678172160.000, b = y[0] = -528261601, c = y[0] = -528276144, d = 0.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>
<p><b>Incluimos el segudo reduce</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel for num_threads(10) private(i) shared(x, y, n) reduction(^:b) reduction(min:c) 
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}

</pre>
<p><b>Resultados</b>
</p>

<p>Checkpoint 1: a = x[7] = 0.000, b = y[7] = 22000, c = y[7] = 22000, d = 0.000 Thread # 7
</p>
<p>Checkpoint 1: a = x[6] = 235.688, b = y[6] = 1131131152, c = y[6] = 1131131152, d = 235.688 Thread # 6
</p>
<p>Checkpoint 1: a = x[9] = 0.000, b = y[9] = 32766, c = y[9] = 32766, d = 0.000 Thread # 9
</p>
<p>Checkpoint 1: a = x[4] = 0.000, b = y[4] = 1131132000, c = y[4] = 1131132000, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[5] = 0.000, b = y[5] = 22000, c = y[5] = 22000, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[2] = 0.000, b = y[2] = 0, c = y[2] = 0, d = 0.000 Thread # 2
</p>
<p>Checkpoint 1: a = x[3] = 0.000, b = y[3] = 0, c = y[3] = 0, d = 0.000 Thread # 3
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 1: a = x[8] = 0.000, b = y[8] = -1264125824, c = y[8] = -1264125824, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 2: a = x[0] = 0.000, b = y[0] = -1264156146, c = y[0] = -1264125824, d = 0.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>

<p><b>Incluimos el ultimo reduce</b>
</p>
<pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;omp.h&gt;
#include &lt;assert.h&gt;

#define TAMANO 10

void reduction1(float *x, int *y, int n);

int main()
{
    int n = 10;
    float x[TAMANO];
    int y[TAMANO];

    reduction1(x, y, n);
    return 0;
}

void reduction1(float *x, int *y, int n)
{
    int i, b, c;
    float a, d;
    
    a = 0.0;
    b = 0;
    c = y[0];
    d = x[0];
    
    #pragma omp parallel for num_threads(10) private(i) shared(x, y, n) reduction(^:b) reduction(min:c) reduction(max:d)
    for (i = 0; i &lt; n; i++)
    {
        a += x[i];
        b ^= y[i];
        
        if (c &gt; y[i]) c = y[i];
	
        d = fmaxf(d, x[i]);
	
        printf(&quot;Checkpoint 1: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    }
    printf(&quot;Checkpoint 2: a = x[%d] = %.3f, b = y[%d] = %d, c = y[%d] = %d, d = %.3f Thread # %d\n\n&quot;, i, a, i, b, i, c, d, omp_get_thread_num());
    
}

</pre>
<p><b>Resultados</b>
</p>
<p>Checkpoint 1: a = x[7] = -0.000, b = y[7] = 21920, c = y[7] = 21920, d = 0.000 Thread # 7
</p>
<p>Checkpoint 1: a = x[6] = -0.000, b = y[6] = -1904135920, c = y[6] = -1904135920, d = -0.000 Thread # 6
</p>
<p>Checkpoint 1: a = x[8] = 0.000, b = y[8] = -559857520, c = y[8] = -559857520, d = 0.000 Thread # 8
</p>
<p>Checkpoint 1: a = x[1] = 0.000, b = y[1] = 0, c = y[1] = 0, d = 0.000 Thread # 1
</p>
<p>Checkpoint 1: a = x[0] = 0.000, b = y[0] = 0, c = y[0] = 0, d = 0.000 Thread # 0
</p>
<p>Checkpoint 1: a = x[3] = -0.000, b = y[3] = 0, c = y[3] = 0, d = 0.000 Thread # 3
</p>
<p>Checkpoint 1: a = x[4] = -0.000, b = y[4] = -1904135024, c = y[4] = -1904135024, d = 0.000 Thread # 4
</p>
<p>Checkpoint 1: a = x[2] = 6425019940864.000, b = y[2] = 0, c = y[2] = 0, d = 6425019940864.000 Thread # 2
</p>
<p>Checkpoint 1: a = x[5] = -0.000, b = y[5] = 21920, c = y[5] = 21920, d = 0.000 Thread # 5
</p>
<p>Checkpoint 1: a = x[9] = -0.000, b = y[9] = 32767, c = y[9] = 32767, d = 0.000 Thread # 9
</p>
<p>Checkpoint 2: a = x[0] = 6425019940864.000, b = y[0] = -559858961, c = y[0] = -1904135920, d = 6425019940864.000 Thread # 0
</p>
<p><b>Análisis y conclusión</b>
</p>






<hr size="6">
<a name="SEC_Contents"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<h1>&Iacute;ndice General</h1>
<div class="contents">

<ul class="toc">
  <li><a name="toc-Introduccion" href="#node_005fchapter_005f1">1. Introducción</a>
  <ul class="toc">
    <li><a name="toc-SorJuana" href="#node_005fsection_005f1_005f1">1.1 SorJuana</a>
    <ul class="toc">
      <li><a name="toc-Informacion" href="#node_005fsubsection_005f1_005f1_005f1">1.1.1 Información</a></li>
    </ul></li>
    <li><a name="toc-OpenMP_003f" href="#node_005fsection_005f1_005f2">1.2 OpenMP?</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-1_002e1" href="#node_005fsubsection_005f1_005f2_005f1">1.2.1 Ejemplo 1.1</a></li>
      <li><a name="toc-Ejemplo-2_002e1" href="#node_005fsubsection_005f1_005f2_005f2">1.2.2 Ejemplo 2.1</a></li>
      <li><a name="toc-Ejemplo-2_002e3" href="#node_005fsubsection_005f1_005f2_005f3">1.2.3 Ejemplo 2.3</a></li>
    </ul></li>
    <li><a name="toc-Compilacion" href="#node_005fsection_005f1_005f3">1.3 Compilación</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-3_002e1" href="#node_005fsubsection_005f1_005f3_005f1">1.3.1 Ejemplo 3.1</a></li>
    </ul>
</li>
  </ul></li>
  <li><a name="toc-Directivas" href="#node_005fchapter_005f2">2. Directivas</a>
  <ul class="toc">
    <li><a name="toc-Flush" href="#node_005fsection_005f2_005f4">2.1 Flush</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-2_002e2" href="#node_005fsubsection_005f2_005f4_005f1">2.1.1 Ejemplo 2.2</a></li>
    </ul>
</li>
  </ul></li>
  <li><a name="toc-Clausulas" href="#node_005fchapter_005f3">3. Clausulas</a>
  <ul class="toc">
    <li><a name="toc-Private" href="#node_005fsection_005f3_005f1">3.1 Private</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-35_002e1" href="#node_005fsubsection_005f3_005f1_005f1">3.1.1 Ejemplo 35.1</a></li>
      <li><a name="toc-Ejemplo-35_002e2" href="#node_005fsubsection_005f3_005f1_005f2">3.1.2 Ejemplo 35.2</a></li>
      <li><a name="toc-Ejemplo-35_002e3" href="#node_005fsubsection_005f3_005f1_005f3">3.1.3 Ejemplo 35.3</a></li>
    </ul></li>
    <li><a name="toc-Firstprivate" href="#node_005fsection_005f3_005f2">3.2 Firstprivate</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-37_002e1" href="#node_005fsubsection_005f3_005f2_005f1">3.2.1 Ejemplo 37.1</a></li>
    </ul></li>
    <li><a name="toc-Lastprivate" href="#node_005fsection_005f3_005f3">3.3 Lastprivate</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-38_002e1" href="#node_005fsubsection_005f3_005f3_005f1">3.3.1 Ejemplo 38.1</a></li>
    </ul></li>
    <li><a name="toc-Reduction" href="#node_005fsection_005f3_005f4">3.4 Reduction</a>
    <ul class="toc">
      <li><a name="toc-Ejemplo-39_002e1" href="#node_005fsubsection_005f3_005f4_005f1">3.4.1 Ejemplo 39.1</a></li>
    </ul>
</li>
  </ul>
</li>
</ul>
</div>
<hr size="1">
<a name="SEC_About"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Top" title="Portada del documento">Arriba</a>]</td>
<td valign="middle" align="left">[<a href="#SEC_Contents" title="&Iacute;ndice general">&Iacute;ndice general</a>]</td>
<td valign="middle" align="left">[&Iacute;ndice]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="Acerca de (p&aacute;gina de ayuda)"> ? </a>]</td>
</tr></table>
<h1>Acerca de este documento</h1>
<p>
  Este documento ha sido generado por <em>Gustavo Magallanes GuijÃ³n</em> el <em>el 7 octubre 2019</em> utilizando <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
</p>
<p>
  Los botones de los paneles de navegaci&oacute;n tienen el significado siguiente:
</p>
<table border="1">
  <tr>
    <th> Bot&oacute;n </th>
    <th> Nombre </th>
    <th> Ir a </th>
    <th> Desde 1.2.3 ir a</th>
  </tr>
  <tr>
    <td align="center"> [ &lt; ] </td>
    <td align="center">Atr&aacute;s</td>
    <td>Secci&oacute;n anterior en orden de lectura</td>
    <td>1.2.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt; ] </td>
    <td align="center">Adelante</td>
    <td>Secci&oacute;n siguiente en orden de lectura</td>
    <td>1.2.4</td>
  </tr>
  <tr>
    <td align="center"> [ &lt;&lt; ] </td>
    <td align="center">Retroceso r&aacute;pido</td>
    <td>Inicio de este cap&iacute;tulo o cap&iacute;tulo anterior</td>
    <td>1</td>
  </tr>
  <tr>
    <td align="center"> [ Subir ] </td>
    <td align="center">Subir</td>
    <td>Subir secci&oacute;n</td>
    <td>1.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt;&gt; ] </td>
    <td align="center">Avance r&aacute;pido</td>
    <td>Cap&iacute;tulo siguiente</td>
    <td>2</td>
  </tr>
  <tr>
    <td align="center"> [Arriba] </td>
    <td align="center">Arriba</td>
    <td>Portada del documento</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [&Iacute;ndice general] </td>
    <td align="center">&Iacute;ndice general</td>
    <td>&Iacute;ndice general</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [&Iacute;ndice] </td>
    <td align="center">&Iacute;ndice</td>
    <td>&Iacute;ndice</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [ ? ] </td>
    <td align="center">Acerca de</td>
    <td>Acerca de (p&aacute;gina de ayuda)</td>
    <td> &nbsp; </td>
  </tr>
</table>

<p>
  donde el <strong> Ejemplo </strong> supone que la posiciÃ³n actual estÃ¡ en la <strong> Sub-subsecci&oacute;n uno-dos-tres </strong> de un documento de la estructura siguiente:
</p>

<ul>
  <li> 1. Secci&oacute;n Uno
    <ul>
      <li>1.1 Subsecci&oacute;n uno-uno
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.2 Subsecci&oacute;n uno-dos
        <ul>
          <li>1.2.1 Sub-subsecci&oacute;n uno-dos-uno</li>
          <li>1.2.2 Sub-subsecci&oacute;n uno-dos-dos</li>
          <li>1.2.3 Sub-subsecci&oacute;n uno-dos-tres &nbsp; &nbsp;
            <strong>&lt;== Posici&oacute;n actual </strong></li>
          <li>1.2.4 Sub-subsecci&oacute;n uno-dos-cuatro</li>
        </ul>
      </li>
      <li>1.3 Subsecci&oacute;n uno-tres
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.4 Subsecci&oacute;n uno-cuatro</li>
    </ul>
  </li>
</ul>

<hr size="1">
<p>
 <font size="-1">
  Este documento ha sido generado por <em>Gustavo Magallanes GuijÃ³n</em> el <em>el 7 octubre 2019</em> utilizando <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
